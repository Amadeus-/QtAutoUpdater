/*!
@class QtAutoUpdater::TimeSpan

A timespan defines an abstract amount of time that consits of a unit, e.g. seconds or
minutes, and a count. The result could be for example `42 Seconds`.

For now, the timespan is a very simple object, but in future versions it will be extended
(and propably moved outside of this project) to reach it's full capability.
*/

/*!
@fn QtAutoUpdater::TimeSpan::msecs

@returns A number that equals the timespan in milliseconds

To do this, the TimeSpan will simply multiply `count` with `unit`.
@warning For now, the timespan does **not** check on overflows. This means that it is
possible for the result to be invalid, if `count Ã— unit` is greater than
`UNSIGNED_LONG_LONG_MAX`
*/

/*!
@fn QtAutoUpdater::TimeSpan::addToDateTime

@param base The datetime to add this timespan to
@returns The new datetime with the added timespan

Tries to add the timespan to the QDateTime.
@warning For now, the timespan does **not** check on overflows. This means that for
example QDateTime::addMonths takes a normal `int` instead of `quint64`. The TimeSpan will
not handle such overflows.
*/

/*!
@class QtAutoUpdater::UpdateTask

The UpdateTask defines the basic methods needed to be scheduled. Tasks can basically be
anything, e.g. an infinite loop that triggers every 42 seconds, or a task that only fires
once on a specific date and time, ...

@warning This is important for all UpdateTask subclasses! The UpdateScheduler will take
ownership of the tasks and handel them in a different thread. The classes do not have
to be thread-safe, as long as you don't access them anymore after passing them to the
scheduler!

### Subclassing
If you want to create your own task, you should implement the methods like shown below.
But before doing that, you should check if the provided subclasses can fullfill your
task. Those are:
 - BasicLoopUpdateTask (based on LoopUpdateTask)
 - TimePointUpdateTask
 - UpdateTaskList

##### hasTasks:
Should return true, as long as the Task has timepoints to be fired at. You should also
add checks inside that function to validate the task. In addition to that, this method
serves as initialisation, since UpdateTasks can be created any time without beeing used.
But as soons as hasTasks() gets called the first time, the task is "in schedule", meaning
it will be take care of it until it completed or the application shuts down.

##### currentTask:
Should return the next timepoint for this task. Please make shure this function always
returns the same value for multiple calls until nextTask() was called. Otherwise, it's
not guaranteed that your task will be properly scheduled. Please note that if your return
a QDateTime that lays in the past, the whole task-object will be assumed "finished" and
be deleted.

##### nextTask:
Your implementation should move on to the next timepoint where it should be fired. After
a call to this function currentTask() should return a new QDateTime. If you were able to
proceed to the next task, return true. If it failed, or you don't have any tasks left
(e.g. your task is a oneshot), return false and the task-object will be assumed "finished" and
be deleted.

##### typeIndex:
All this function should do is return `typeid(&lt;MyUpdateTask&gt;)`. This is required
for a unique identification of each type.

##### store:
Should write all data this object holds into a bytearray for later usage. This only happens
if the application is about to shut down. This way, the scheduler can reload the task from
the settings and continue it. If you don't need to support this, just return an empty QByteArray.

If you however want to make use of it, you will have to make shure that your UpdateTask
is registered as a storable task. This can be done by calling
`UpdateSchedulerController::registerStoredTask&lt;MyUpdateTask&gt;();`. In addition to
that, your task needs to provide a public constructor that takes a QByteArray as parameter.

@sa UpdateScheduler, LoopUpdateTask, BasicLoopUpdateTask, TimePointUpdateTask,
UpdateTaskList, Updater::scheduleUpdate(UpdateTask *),
UpdaterController::scheduleUpdate(UpdateTask *, DisplayLevel)
*/

/*!
@fn QtAutoUpdater::UpdateTask::hasTasks

@returns `true`, if valid tasks are available, `false` if not

@sa UpdateTask
*/

/*!
@fn QtAutoUpdater::UpdateTask::currentTask

@returns the timepoint of the current task of this object

@sa UpdateTask
*/

/*!
@fn QtAutoUpdater::UpdateTask::nextTask

@returns `true`, if the UpdateTask was able to proceed to the next subtask, `false` if not

@sa UpdateTask
*/

/*!
@fn QtAutoUpdater::UpdateTask::typeIndex

@returns the `typeid` of the class that implements this method

@sa UpdateTask
*/

/*!
@fn QtAutoUpdater::UpdateTask::store

@returns A QByteArray that contains a serialized version of the UpdateTask

@sa UpdateTask
*/

/*!
@class QtAutoUpdater::LoopUpdateTask

The LoopUpdateTask is a baseclass to simplify the implementation of looped tasks. Please
note that this implementation will not care about storing and loading data. It only
"translates" the returns of the prue virtual functions into the ones required by an
UpdateTask

@sa UpdateTask, BasicLoopUpdateTask
*/

/*!
@fn QtAutoUpdater::LoopUpdateTask::startDelay

@returns A TimeSpan to be waited from the activation until the first trigger

The default implementation will return LoopUpdateTask::pauseSpan.

@sa LoopUpdateTask::pauseSpan, UpdateTask, BasicLoopUpdateTask
*/

/*!
@fn QtAutoUpdater::LoopUpdateTask::repetitions

@returns The number of repetitions to be done

Should return how often this task should be triggered. Should be at least 1 (0 is invalid).
If you want the task to be infinite, return any number below 0 (e.g. -1).

@sa UpdateTask, BasicLoopUpdateTask
*/

/*!
@fn QtAutoUpdater::LoopUpdateTask::pauseSpan

@returns A TimeSpan to be waited between each trigger

Return the wait-delay between each trigger. Make shure the value is great enough, since
very small timespans (e.g. 1 Second) will propably fail or slow down the program.

@sa LoopUpdateTask::startDelay, UpdateTask, BasicLoopUpdateTask
*/

/*!
@fn QtAutoUpdater::LoopUpdateTask::getLeftReps

@returns The repetitions that are left to be done

This number will decrease on every triggered task (except if it's below 0, since that
are infinite loops). If this value reaches 0, the task will be destroyed

@sa LoopUpdateTask::repetitions, UpdateTask, BasicLoopUpdateTask
*/

/*!
@class QtAutoUpdater::BasicLoopUpdateTask

The BasicLoopUpdateTask is a simple implementation of a LoopUpdateTask. It consists of
a timespan that serves as startDelay and pauseSpan, and a number of repetitions.

@note This task will be stored automatically. It will save the delay and the
repetitions left. If all repetions are done, the task will be deleted (and thus not
stored anymore)

@sa LoopUpdateTask
*/

/*!
@fn QtAutoUpdater::BasicLoopUpdateTask::BasicLoopUpdateTask(TimeSpan, qint64)

@overload
@param loopDelta The TimeSpan to wait between repetitons
@param repeats The number of repetitions for this task

Creates a BasicLoopUpdateTask from a timespan and repetitions. if `repeats` is below
0, the task will be an infinite loop

@overloads{
	@povElem{BasicLoopUpdateTask(TimeSpan, qint64)}
	@ovElem{BasicLoopUpdateTask(const QByteArray &)}
}
*/

/*!
@fn QtAutoUpdater::BasicLoopUpdateTask::BasicLoopUpdateTask(const QByteArray &)

@overload
@param data The raw data to create this task from

@attention This Constructor is required for internal use. You should not call it
yourself!

Creates a BasicLoopUpdateTask from stored data.
Any data returned from BasicLoopUpdateTask::store can be passed to this constructor.
Invalid data will result in an invalid object.

@overloads{
	@povElem{BasicLoopUpdateTask(TimeSpan, qint64)}
	@ovElem{BasicLoopUpdateTask(const QByteArray &)}
}

@sa BasicLoopUpdateTask::store
*/

/*!
@class QtAutoUpdater::TimePointUpdateTask

The TimePointUpdateTask represents a task to be triggered at a specific timepoint.
It optionally offers to repeat that timepoint on a specific focus. For example,
you can set the task to a specific timepoint and tell it to repeat every month. This
would mean that beginning with the timepoint, the task will be triggered every month
at the same day and time.

@note This task will be stored automatically. It will save the next time and the
repetition focus. If all repetions are done, the task will be deleted (and thus not
stored anymore)

@sa UpdateTask
*/

/*!
@fn QtAutoUpdater::TimePointUpdateTask::TimePointUpdateTask(const QDateTime &, TimeSpan::TimeUnit)

@overload
@param timePoint The first timepoint this task should be triggered
@param repeatFocus The focus for repetitions

Creates a TimePointUpdateTask to be triggered the first time at `timePoint`. If
`repeatFocus` equals something different than TimeSpan::MilliSeconds, the task will
repeat every "focus". (e.g. if focus equals week, the task will be triggered every week
at the same weekday and time). If it equals TimeSpan::MilliSeconds (the default), it
will not be repeated and only triggered once at `timePoint`.

@overloads{
	@povElem{TimePointUpdateTask(const QDateTime &, TimeSpan::TimeUnit)}
	@ovElem{TimePointUpdateTask(const QByteArray &)}
}
*/

/*!
@fn QtAutoUpdater::TimePointUpdateTask::TimePointUpdateTask(const QByteArray &)

@overload
@param data The raw data to create this task from

@attention This Constructor is required for internal use. You should not call it
yourself!

Creates a TimePointUpdateTask from stored data.
Any data returned from TimePointUpdateTask::store can be passed to this constructor.
Invalid data will result in an invalid object.

@overloads{
	@povElem{TimePointUpdateTask(const QDateTime &, TimeSpan::TimeUnit)}
	@ovElem{TimePointUpdateTask(const QByteArray &)}
}

@sa TimePointUpdateTask::store
*/

/*!
@class QtAutoUpdater::UpdateTaskList

The UpdateTaskList represents a list of tasks. These tasks can be any kind of UpdateTasks.
The list itself will simply handle one task after another. This means all added tasks
(except of the last one) should not be infinite, because this way the list would stick
with that task forever.

@note This task will be stored automatically. It will store all the task in the list
that are storeable. If a task is not, it will simply be discarded.

@sa UpdateTask
*/

/*!
@fn QtAutoUpdater::UpdateTaskList::UpdateTaskList()

@overload

The tasklist will be empty. Since this class inherits QLinkedList, you can add tasks
using for example QLinkedList::append.

@attention Please remember that the UpdateScheduler will take ownership of the task
once you pass it. You must not add new tasks once this task is scheduled

@overloads{
	@povElem{UpdateTaskList()}
	@ovElem{UpdateTaskList(const std::initializer_list<UpdateTask*> &)}
	@ovElem{UpdateTaskList(const QByteArray &)}
}
*/

/*!
@fn QtAutoUpdater::UpdateTaskList::UpdateTaskList(const std::initializer_list<UpdateTask*> &)

@overload
@param list An initializer list of UpdateTasks to fill this list with

@overloads{
	@povElem{UpdateTaskList()}
	@ovElem{UpdateTaskList(const std::initializer_list<UpdateTask*> &)}
	@ovElem{UpdateTaskList(const QByteArray &)}
}
*/

/*!
@fn QtAutoUpdater::UpdateTaskList::UpdateTaskList(const QByteArray &)

@overload
@param data The raw data to create this task from

@attention This Constructor is required for internal use. You should not call it
yourself!

Creates a UpdateTaskList from stored data.
Any data returned from UpdateTaskList::store can be passed to this constructor.
Invalid data will result in an invalid object.

@overloads{
	@povElem{UpdateTaskList()}
	@ovElem{UpdateTaskList(const std::initializer_list<UpdateTask*> &)}
	@ovElem{UpdateTaskList(const QByteArray &)}
}

@sa UpdateTaskList::store
*/
