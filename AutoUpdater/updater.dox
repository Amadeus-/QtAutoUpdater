/*!
@namespace QtAutoUpdater

@brief The QtAutoUpdater namespace holds all classes that are related with the updater

This namespace includes both, the core library and the widgets library. Please note that
the two are seperate libraries, that only share the namespace. The Core-Library is
independet of the Widgets-Library and won't need a gui. The Widgets-Library requires both,
a gui and the Core-Library.

## Core-Library:
 - Updater : The main updater class
 - UpdateScheduler : Responsilbe for update-scheduling. Mainly internal, but public
accessible
 - UpdateTask : Base class for all update tasks. The most useful are:
   - TimeSpan : Represents a timespan with a timeunit
   - BasicLoopUpdateTask : An (optinally) repeated timespan
   - TimePointUpdateTask : A specific timepoint (with optional repeating every year/month/...)
   - UpdateTaskList : An abstract list of different sequential update tasks

## Widgets-Libray:
 - UpdateController : A gui-controller to automate the update process and show information to the user
*/

/*!
@class QtAutoUpdater::Updater

The updater class has the task to run the maintenancetool to check for updates. It will
evalute the results of the tool and generate update information of it. In addition of that,
it can schedule the maintenancetool to run in updater mode as soon as the application
finishes. (This requires the Updater instance to exist until QCoreApplication::quit is called).
*/

/*!
@property QtAutoUpdater::Updater::maintenanceToolPath

@default{"./maintenancetool"}

The path of the maintenancetool has to be set inside of the constructor and cannot be
changed later.<br>
The path will be assumed relative to QCoreApplication::applicationDirPath(), the location
of the currently running application.

@note On Mac, the current path will be the AppFolder, for example:
<i>/Applications/MyApp.app</i> instead off <i>/Applications/MyApp.app/Contents/MacOS</i>

The updater will check whether or not the given path has a file-extension. If not, it
will try to add the given extension. This will result into:

 - **Windows**: "./maintenancetool.exe"
 - **Mac**: "./maintenancetool.app/Content/MacOS/maintenancetool"
 - **X11**: "./maintenancetool" (unchanged)

@accessors{
	@readAc{maintenanceToolPath()}
	@constantAc
	@finalAc
}
*/

/*!
@property QtAutoUpdater::Updater::running

@default{`false`}

The updater can only check for updates once at a time. If this property returns `true`,
you will have to wait for it to finish to get your update result or check for updates again.

@accessors{
	@readAc{isRunning()}
	@notifyAc{runningChanged()}
}
*/

/*!
@property QtAutoUpdater::Updater::updateInfo

@default{&lt;empty list&gt;}

The update result is only valid for the last update check and won't be updated until
you check for updates again. When checking for updates, the list will be cleared before
the updater starts the check.<br>
To find out whether the list is truly empty or just because the updater is running, use
the Updater::running property. If it returns `false`, you can assume that the value of this
property is the result of the last update check (if one happend).

@accessors{
	@readAc{updateInfo()}
	@notifyAc{updateInfoChanged()}
}
*/

/*!
@fn QtAutoUpdater::Updater::Updater(QObject *)

@overload
@param parent The object parent for QObject

The maintenancetool path will be set to the default one (and cannot be changed).
See Updater::maintenanceToolPath for more details.
*/

/*!
@fn QtAutoUpdater::Updater::Updater(const QString &, QObject *)

@overload
@param maintenanceToolPath The path to the maintenancetool executable
@param parent The object parent for QObject

The maintenancetool path will be set to the given one (and cannot be changed).
See Updater::maintenanceToolPath for more details.
*/

/*!
@fn QtAutoUpdater::Updater::~Updater

Desytroyes the updater. If the maintenancetool process is still running, it will be killed
(hard, not friendly). To avoid this, check if Updater::running returns `false` or use
Updater::abortUpdateCheck to gracefully shut down the maintenancetool
*/

/*!
@fn QtAutoUpdater::Updater::exitedNormally

@returns `true`, if the maintenancetool finished normally, `false` if not

Exiting normally does **not** mean the the update was successfull, only that the
maintenancetool exited itself and was not killed or crashed.<br>
If `false` is returned, in most cases the process either crashed or was never even
able to start.

While the updater is running, this function will always return `true`.

@note Depending on the return of this function, the meaning of Updater::getErrorCode
and Updater::getErrorLog will change!
*/

/*!
@fn QtAutoUpdater::Updater::getErrorCode

@returns The exit-code of the maintenancetool or an error code

@note The meaning of this functions return value depends on what Updater::exitedNormally
returns

If the maintenancetool exited normally, this function will return the actual exit code
of the maintenancetool. Please not that `EXIT_SUCCESS (0)` means that there are updates
available and `EXIT_FAILURE (1)` can mean either no updates or some other kind of error.
Please check the <a href="https://doc.qt.io/qtinstallerframework/" target="_blank">Qt Installer Framework</a>
documentation for more details about the tool itself.

If the maintenancetool did not exit normally, the returned error-code will be one of
QProcess::ProcessError.

While the updater is running, this function will always return 0.
*/

/*!
@fn QtAutoUpdater::Updater::getErrorLog

@returns The error log of the last run of the maintenancetool

@note The meaning of this functions return value depends on what Updater::exitedNormally
returns

If the maintenancetool exited normally, this function will return the cerr (standard error)
output generated by the maintenancetool. If the maintenancetool actually fails, you
can use this to find out why.

If the maintenancetool did not exit normally, the returned error-code will be the error
string of the last devide error of the process, i.e. QProcess::errorString

While the updater is running, this function will always return an empty QByteArray.
*/

/*!
@fn QtAutoUpdater::Updater::willRunOnExit

@returns `true`, if the maintenancetool will run on application exit

For more details about "running on exit", check Updater::runUpdaterOnExit
*/

/*!
@fn QtAutoUpdater::Updater::checkForUpdates

@returns `true`, if the check for updates process was started

Checking for updates means that the maintenancetool will be run in background
using `--checkupdates` as parameter. The function will return immideatly after the
process was started.

If no update process is currently running, `true` will be returned, no matter whether the
maintenancetool was actually startet or not. To check if it was successfull, wait for
checkUpdatesDone() to be emitted and check the result using Updater::exitedNormally,
Updater::getErrorCode and Updater::getErrorLog. Updater::running will be set to `true`.

If the updater is already running the maintenancetool, `false` will be returned and
nothing will happen
*/

/*!
@fn QtAutoUpdater::Updater::abortUpdateCheck

@param maxDelay The maximum delay to wait for the process to finish
@param async If `true`, the wait will be done asynchrounusly

Tries to abort the update check. If no update is currently running (Updater::running
returns `false`), nothing will happen.

If `maxDelay` is greater than 0, the updater will try to gracefully terminate
(QProcess::terminate) the process. After this is done, the updater will wait at most
`maxDelay` milliseconds for the process to finish. If it doesn't, it will be killed
(QProcess::kill).

If `async` is `false`, this function will not return until the process was actually
terminated (or killed). If it's `true`, the function will return immediately. You can
use Updater::running. To find out when the process actually finishes.
*/

/*!
@fn QtAutoUpdater::Updater::scheduleUpdate(qint64 , bool)

@overload
@param delayMinutes The time (in minutes) to wait until the update is started
@param repeated Specifies, whether the updater should be started every `delayMinutes`
or only once
@returns The internal ID of this update task. Can be used to cancel the task

Schedules an update to be run after `delayMinutes` minutes. If `repeated` is `true`, the
updater will not just be run once, but every `delayMinutes` minutes (infinitly, until
this instance is destroyed or the task canceled).

To cancel the update task, call Updater::cancelScheduledUpdate.

For more details, check scheduleUpdate(UpdateTask *)
*/

/*!
@fn QtAutoUpdater::Updater::scheduleUpdate(const QDateTime &)

@overload
@param when The timepoint where the update should be started
@returns The internal ID of this update task. Can be used to cancel the task

Schedules an update to be run at `when`. If `when` lays in the past, nothing will happen.
The update will be started once that time is reached (assuming that this updater instance
is still alive at that timepoint).

To cancel the update task, call Updater::cancelScheduledUpdate.

For more details, check scheduleUpdate(UpdateTask *)
*/

/*!
@fn QtAutoUpdater::Updater::scheduleUpdate(UpdateTask *)

@overload
@param task The task to be scheduled
@returns The internal ID of this update task. Can be used to cancel the task

Uses `task` to schedule updates. For more details about the different tasks, check
the UpdateTask documentation.

To cancel the update task, call Updater::cancelScheduledUpdate.
*/
